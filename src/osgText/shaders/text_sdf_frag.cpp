char text_sdf_frag[] = "$OSG_GLSL_VERSION\n"
                       "\n"
                       "#pragma import_defines( BACKDROP_COLOR, OUTLINE, SIGNED_DISTNACE_FIELD, TEXTURE_DIMENSION, GLYPH_DIMENSION)\n"
                       "\n"
                       "#ifdef GL_ES\n"
                       "    #extension GL_OES_standard_derivatives : enable\n"
                       "    #ifndef GL_OES_standard_derivatives\n"
                       "        #undef SIGNED_DISTNACE_FIELD\n"
                       "    #endif\n"
                       "#endif\n"
                       "\n"
                       "$OSG_PRECISION_FLOAT\n"
                       "\n"
                       "#undef SIGNED_DISTNACE_FIELD\n"
                       "\n"
                       "#if __VERSION__>=130\n"
                       "    #define TEXTURE texture\n"
                       "    #define TEXTURELOD textureLod\n"
                       "    out vec4 osg_FragColor;\n"
                       "#else\n"
                       "    #define TEXTURE texture2D\n"
                       "    #define TEXTURELOD texture2DLod\n"
                       "    #define osg_FragColor gl_FragColor\n"
                       "#endif\n"
                       "\n"
                       "uniform sampler2D glyphTexture;\n"
                       "\n"
                       "$OSG_VARYING_IN vec2 texCoord;\n"
                       "$OSG_VARYING_IN vec4 vertexColor;\n"
                       "\n"
                       "#ifdef SIGNED_DISTNACE_FIELD\n"
                       "\n"
                       "float distanceFromEdge(vec2 tc)\n"
                       "{\n"
                       "    float center_alpha = TEXTURELOD(glyphTexture, tc, 0.0).r;\n"
                       "    if (center_alpha==0.0) return -1.0;\n"
                       "\n"
                       "    //float distance_scale = (1.0/4.0)*1.41;\n"
                       "    float distance_scale = (1.0/6.0)*1.41;\n"
                       "    //float distance_scale = (1.0/8.0)*1.41;\n"
                       "\n"
                       "    return (center_alpha-0.5)*distance_scale;\n"
                       "}\n"
                       "\n"
                       "vec4 distanceFieldColorSample(float edge_distance, float blend_width, float  blend_half_width)\n"
                       "{\n"
                       "#ifdef OUTLINE\n"
                       "    float outline_width = OUTLINE*0.5;\n"
                       "    if (edge_distance>blend_half_width)\n"
                       "    {\n"
                       "        return vertexColor;\n"
                       "    }\n"
                       "    else if (edge_distance>-blend_half_width)\n"
                       "    {\n"
                       "        return mix(vertexColor, BACKDROP_COLOR, smoothstep(0.0, 1.0, (blend_half_width-edge_distance)/(blend_width)));\n"
                       "    }\n"
                       "    else if (edge_distance>(blend_half_width-outline_width))\n"
                       "    {\n"
                       "        return BACKDROP_COLOR;\n"
                       "    }\n"
                       "    else if (edge_distance>-(outline_width+blend_half_width))\n"
                       "    {\n"
                       "        return vec4(BACKDROP_COLOR.rgb, ((blend_half_width+outline_width+edge_distance)/blend_width));\n"
                       "    }\n"
                       "    else\n"
                       "    {\n"
                       "        return vec4(0.0, 0.0, 0.0, 0.0);\n"
                       "    }\n"
                       "#else\n"
                       "    if (edge_distance>blend_half_width)\n"
                       "    {\n"
                       "        return vertexColor;\n"
                       "    }\n"
                       "    else if (edge_distance>-blend_half_width)\n"
                       "    {\n"
                       "        return vec4(vertexColor.rgb, smoothstep(1.0, 0.0, (blend_half_width-edge_distance)/(blend_width)));\n"
                       "    }\n"
                       "    else\n"
                       "    {\n"
                       "        return vec4(0.0, 0.0, 0.0, 0.0);\n"
                       "    }\n"
                       "#endif\n"
                       "}\n"
                       "\n"
                       "vec4 distanceFieldColor()\n"
                       "{\n"
                       "    float sample_distance_scale = 0.75;\n"
                       "    vec2 dx = dFdx(texCoord)*sample_distance_scale;\n"
                       "    vec2 dy = dFdy(texCoord)*sample_distance_scale;\n"
                       "\n"
                       "    #ifndef TEXTURE_DIMENSION\n"
                       "    float TEXTURE_DIMENSION = 1024.0;\n"
                       "    #endif\n"
                       "\n"
                       "    #ifndef GLYPH_DIMENSION\n"
                       "    float GLYPH_DIMENSION = 32.0;\n"
                       "    #endif\n"
                       "\n"
                       "    float distance_across_pixel = length(dx+dy)*(TEXTURE_DIMENSION/GLYPH_DIMENSION);\n"
                       "\n"
                       "    // compute the appropriate number of samples required to avoid aliasing.\n"
                       "    int maxNumSamplesAcrossSide = 4;\n"
                       "\n"
                       "    int numSamplesX = int(TEXTURE_DIMENSION * length(dx));\n"
                       "    int numSamplesY = int(TEXTURE_DIMENSION * length(dy));\n"
                       "    if (numSamplesX<2) numSamplesX = 2;\n"
                       "    if (numSamplesY<2) numSamplesY = 2;\n"
                       "    if (numSamplesX>maxNumSamplesAcrossSide) numSamplesX = maxNumSamplesAcrossSide;\n"
                       "    if (numSamplesY>maxNumSamplesAcrossSide) numSamplesY = maxNumSamplesAcrossSide;\n"
                       "\n"
                       "\n"
                       "    vec2 delta_tx = dx/float(numSamplesX-1);\n"
                       "    vec2 delta_ty = dy/float(numSamplesY-1);\n"
                       "\n"
                       "    float numSamples = float(numSamplesX)*float(numSamplesY);\n"
                       "    float scale = 1.0/numSamples;\n"
                       "    vec4 total_color = vec4(0.0,0.0,0.0,0.0);\n"
                       "\n"
                       "    float blend_width = 1.5*distance_across_pixel/numSamples;\n"
                       "    float blend_half_width = blend_width*0.5;\n"
                       "\n"
                       "    // check whether fragment is wholly within or outwith glyph body+outline\n"
                       "    float cd = distanceFromEdge(texCoord); // central distance (distance from center to edge)\n"
                       "    if (cd-blend_half_width>distance_across_pixel) return vertexColor; // pixel fully within glyph body\n"
                       "\n"
                       "    #ifdef OUTLINE\n"
                       "    float outline_width = OUTLINE*0.5;\n"
                       "    if ((-cd-outline_width-blend_half_width)>distance_across_pixel) return vec4(0.0, 0.0, 0.0, 0.0); // pixel fully outside outline+glyph body\n"
                       "    #else\n"
                       "    if (-cd-blend_half_width>distance_across_pixel) return vec4(0.0, 0.0, 0.0, 0.0); // pixel fully outside glyph body\n"
                       "    #endif\n"
                       "\n"
                       "\n"
                       "    // use multi-sampling to provide high quality antialised fragments\n"
                       "    vec2 origin = texCoord - dx*0.5 - dy*0.5;\n"
                       "    for(;numSamplesY>0; --numSamplesY)\n"
                       "    {\n"
                       "        vec2 pos = origin;\n"
                       "        int numX = numSamplesX;\n"
                       "        for(;numX>0; --numX)\n"
                       "        {\n"
                       "            vec4 c = distanceFieldColorSample(distanceFromEdge(pos), blend_width, blend_half_width);\n"
                       "            total_color = total_color + c * c.a;\n"
                       "            pos += delta_tx;\n"
                       "        }\n"
                       "        origin += delta_ty;\n"
                       "    }\n"
                       "\n"
                       "    total_color.rgb /= total_color.a;\n"
                       "    total_color.a *= scale;\n"
                       "\n"
                       "    return total_color;\n"
                       "}\n"
                       "#else\n"
                       "\n"
                       "vec4 textureColor()\n"
                       "{\n"
                       "    #ifdef OUTLINE\n"
                       "        // glyph.rgba = (signed_distance, thin_outline, thick_outline, glyph_alpha)\n"
                       "        vec4 glyph = TEXTURE(glyphTexture, texCoord);\n"
                       "\n"
                       "        float outline_alpha = (OUTLINE<=0.05) ? glyph.g : glyph.b;\n"
                       "\n"
                       "        float alpha = glyph.a+outline_alpha;\n"
                       "        if (alpha>1.0) alpha = 1.0;\n"
                       "\n"
                       "        return vec4( vertexColor.rgb*glyph.a + BACKDROP_COLOR.rgb*outline_alpha, alpha);\n"
                       "\n"
                       "    #else\n"
                       "        float alpha = TEXTURE(glyphTexture, texCoord).a;\n"
                       "        if (alpha==0.0) vec4(0.0, 0.0, 0.0, 0.0);\n"
                       "        return vec4(vertexColor.rgb, alpha);\n"
                       "    #endif\n"
                       "}\n"
                       "\n"
                       "#endif\n"
                       "\n"
                       "\n"
                       "void main(void)\n"
                       "{\n"
                       "    if (texCoord.x<0.0 && texCoord.y<0.0)\n"
                       "    {\n"
                       "        osg_FragColor = vertexColor;\n"
                       "        return;\n"
                       "    }\n"
                       "\n"
                       "#ifdef SIGNED_DISTNACE_FIELD\n"
                       "    vec4 color = distanceFieldColor();\n"
                       "#else\n"
                       "    vec4 color = textureColor();\n"
                       "#endif\n"
                       "\n"
                       "    if (color.a==0.0) discard;\n"
                       "\n"
                       "    osg_FragColor = color;\n"
                       "}\n"
                       "\n";
